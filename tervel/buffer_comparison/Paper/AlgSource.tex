% !TEX root = WaitFreeRingBuffer.tex

\newcommand\fetchHead{
\begin{algorithm}[]
\caption{FetchHead $( )$ }
{\fontsize{8}{8}\selectfont
	\begin{algorithmic}[1]
		\State atomic\_fetch\_and\_increment(head)
	\end{algorithmic}
}
\label{alg:wf:example1}
\end{algorithm}
}

\newcommand\fetchTail{
\begin{algorithm}[]
\caption{FetchTail $( )$ }
{\fontsize{8}{8}\selectfont
	\begin{algorithmic}[1]
		\State atomic\_fetch\_and\_increment(tail)
	\end{algorithmic}
}
\label{alg:wf:example2}
\end{algorithm}
}

\newcommand\lfenqueue{
\begin{algorithm}[]
\caption{Enqueue $(val)$ }
{\fontsize{8}{8}\selectfont
	\begin{algorithmic}[1]
		\State TryHelpAnother()

		\State fail\_count = 0

		\While{true}
			\If {is\_full()} \label{alg:lf:enq:full}
				\State \Return false
			\EndIf

			\State seqid = next\_tail\_seq() \label{alg:enq:inc}
			\State pos = get\_position(seqid) \label{alg:enq:pos}
			\State  new\_node = new ElemNode(seqid, val) \label{alg:enq:elemnode}
			\While {true}
				\If {fail\_count++ $==$ MAX\_FAILS}
					\State op = new EnqueueOp(this, val)
					\State make\_announcement(op)
					\State \Return op.result()
				\EndIf

				\State node = buffer[pos].load()
				\If{node.op} \label{alg:enq:op}
					\State node.op.associate(node, \&(buffer[pos]))
					\State continue
				\ElsIf {isSkipped(node)} \label{alg:enq:bit}
					\State break
				\ElsIf {node.seqid $<$ seqid} \label{alg:enq:seqless}
					\State backoff()
					\If {node != buffer[pos].load()}
						\State continue
					\EndIf
				\EndIf

				\If {node.seqid $<=$ seqid  $and$ isEmpty(node)}
					\State success = buffer[pos].cas(node, new\_node) \label{alg:enq:common}
					\If {success}
						\State \Return true
					\EndIf
					\State continue
				\ElsIf {node.seqid $>$ seqid $or$ isElement(node)} \label{alg:enq:seqgreat}
					\State break
				\EndIf

			\EndWhile
		\EndWhile
	\end{algorithmic}
}
\label{alg:lf:enq}
\end{algorithm}
}

\newcommand\wfenqueue{
\begin{algorithm}[]
\caption{Wait-Free Enqueue $op$ }
{\fontsize{8}{8}\selectfont
	\begin{algorithmic}[1]
		\State seqid = get\_tail\_seq() -1
		\While{op.in\_progress()}
			\If {is\_full()}
				\State op.try\_set\_failed()
				\State \Return
			\EndIf

			\State seqid++
			\State pos = get\_position(seqid)
			\State  new\_node = new ElemNode(seqid, val, op)
			\While{op.in\_progress()}
				\State node = buffer[pos].load()
				\If{node.op}
					\State node.op.associate(node, \&(buffer[pos]))
					\State continue
				\ElsIf {isSkipped(node)}
					\State break
				\EndIf

				\If {node.seqid $<$ seqid}
					\State backoff()
					\If {node != buffer[pos].load()}
						\State continue
					\EndIf
				\EndIf

				\If {node.seqid $<=$ seqid  $and$ isEmpty(node)}
					\If {buffer[pos].cas(node, new\_node)}
						\State op.associate(new\_node, \&buffer[pos]);
						\State \Return
					\EndIf
				\ElsIf {node.seqid $>$ seqid $or$ isElement(node)}
					\State break
				\EndIf

			\EndWhile
		\EndWhile
	\end{algorithmic}
}
\label{alg:wf:enq}
\end{algorithm}
}


\newcommand\lfdequeue{
\begin{algorithm}[]
\caption{Dequeue $(\&result)$ }
{\fontsize{8}{8}\selectfont
	\begin{algorithmic}[1]
		\State TryHelpAnother()

		\State fail\_count = 0

		\While{true}
			\If {is\_empty()} \label{alg:lf:deq:empty}
				\State \Return false
			\EndIf

			\State seqid = next\_head\_seq() \label{alg:deq:inc}
			\State pos = get\_position(seqid) \label{alg:deq:pos}
			\State new\_node = new EmptyNode(seqid + capacity) \label{alg:deq:nullnode}
			\While{true}
				\If {fail\_count++ $==$ MAX\_FAILS} \label{alg:deq:maxfail}
					\State op = new DequeueOp(this)
					\State make\_announcement(op)
					\State \Return op.result(result)
				\EndIf

				\State node = buffer[pos].load()

				\If{node.op} \label{alg:deq:op}
					\State node.op.associate(node, \&(buffer[pos]))
					\State continue
				\ElsIf {isSkipped(node) $and$ isEmpty(node)} \label{alg:deq:fix}
					\If {buffer[pos].cas(node, new\_node)}
						\State break
					\Else
						\State continue
					\EndIf
				\ElsIf {seqid $ > $ node.seqid} \label{alg:deq:seqless}
					\State backoff()
					\If {node $==$ buffer[pos].load()}
						\If {isEmpty(node)}
							\If {buffer[pos].cas(node, new\_node)}
								\State break
							\EndIf
						\Else
							\State atomic\_mark\_skip(\&buffer[pos])
						\EndIf
					\EndIf
				\ElsIf {seqid $ < $ node.seqid} \label{alg:deq:seqgreat}
					\State break
				\Else % is not owned
					\If {isElem(node)}
						\If {isSkipped(node)}
							\State new\_node = setSkipped(new\_node)
						\EndIf
						\State success = buffer[pos].cas(node, new\_node) \label{alg:deq:common}
						\If {success}
							\State *result = node.value
							\State \Return true
						\EndIf
					\Else \label{alg:deq:nullnode}
					%isEmpty(node)
						\State backoff()
						\If {node $==$ buffer[pos].load()}
						 	\If {buffer[pos].cas(node, new\_node)}
								\State break
							\EndIf
						\EndIf
					\EndIf
				\EndIf

			\EndWhile
		\EndWhile
	\end{algorithmic}
}
\label{alg:lf:deq}
\end{algorithm}
}


\newcommand\wfdequeue{
\begin{algorithm}[]
\caption{Wait-Free Dequeue $(op)$ }
{\fontsize{8}{8}\selectfont
	\begin{algorithmic}[1]
		\State seqid = get\_head\_seq() -1
		\While{op.in\_progress()}
			\If {is\_empty()}
				\State \Return op.try\_set\_failed()
			\EndIf

			\State seqid++
			\State pos = get\_position(seqid)

			\While{op.in\_progress()}

				\State node = buffer[pos].load()

				\If{node.op}
					\State node.op.associate(node, \&(buffer[pos]))
					\State continue
				\ElsIf {isSkipped(node)}
					\If {isEmpty(node)}
						\If {buffer[pos].cas(node, new\_node) == false}
							\State continue
						\EndIf
					\EndIf
					\State break
				\Else %curr_node is not skip-marked
					\If {seqid $<$ node.seqid}
						\State backoff()
						\If {node $==$ buffer[pos].load()}
							\State break
						\EndIf
					\ElsIf {sec $>$ node.seqid}
						\State break
					\Else % seqid == node.seqid
						\If {isElem(node)}
							\State new\_node = new ElemNode(seqid, node.value, op)
							\If {buffer[pos].cas(node, new\_node)}
								\State op.associate(new\_node, \&(buffer[pos]))
								\State \Return
							\EndIf
						\Else
							\State break
						\EndIf
					\EndIf
				\EndIf
			\EndWhile
		\EndWhile
	\end{algorithmic}
}
\label{alg:wf:deq}
\end{algorithm}
}


\newcommand\dequeueassoc{
\begin{algorithm}[]
\caption{DequeueOp::associate $(node, address)$ }
{\fontsize{8}{8}\selectfont
\begin{algorithmic}[1]
	\State success = helper.cas(null, node) \label{alg:deq:assoc:lin}
	\If {success $or$ helper.load() == node}
		\State new\_node = NullNode(node.seqid + capacity)
		\If{address.cas(node,  new\_node) == false}
			\State node = setSkipped(node)
			\If{address.load() == node}
				\State new\_node = setSkipped(new\_node)
				\State address.cas(node,  new\_node)
			\EndIf
		\EndIf
	\Else
		\State node.op.store(null);
	\EndIf
\end{algorithmic}
}
\label{alg:deq:assoc}
\end{algorithm}
}

\newcommand\enqueueassoc{
\begin{algorithm}[]
\caption{EnqueueOp::associate $(node, address)$ }
{\fontsize{8}{8}\selectfont
\begin{algorithmic}[1]
	\State success = helper.cas(null, node)
	\If {success $or$ helper.load() == node}
		\State node.op.store(NULL)
	\Else
		\State new\_node = NullNode(node.seqid)
		\If{address.cas(node,  new\_node) == false}
			\State node = setSkipped(node)
			\If{address.load() == node}
				\State new\_node = setSkipped(new\_node)
				\State address.cas(node,  new\_node)
			\EndIf
		\EndIf
	\EndIf
\end{algorithmic}
}
\label{alg:enq:assoc}
\end{algorithm}
}
\newcommand\opTryFail{
\begin{algorithm}[]
\caption{Op::try\_set\_failed $()$ }
{\fontsize{8}{8}\selectfont
\begin{algorithmic}[1]
	\State helper.cas(null, FAIL) \label{alg:op:tryfail:lin}
\end{algorithmic}
}
\label{alg:op:tryfail}
\end{algorithm}
}

\newcommand\template{
\begin{algorithm}[]
\caption{template $(operand)$ }
{\fontsize{8}{8}\selectfont
\begin{algorithmic}[1]

\end{algorithmic}
}
\label{alg:template}
\end{algorithm}
}