% !TEX root = WaitFreeRingBuffer.tex

Our approach requires the a sequentially consistent memory model to insure proper ordering of operations, as well as support for the atomic primitives \textit{compare and swap} (\op{cas}), \textit{fetch and add} (\op{faa}), \textit{fetch and or} (\op{fao}), \textit{load}, and \textit{store}.
Our design also reserves the least significant bit of a reference for state identification.

The presented implementation omits details related to memory management of short lived objects (i.e. \descr{Helper} and \descr{Node} objects).
The tested implementation uses a scheme based on the combination of hazard pointers~\ref{todo} and reference counting~\ref{todo} to prevent these objects from being reused prematurely.
Without such protection, it could introduce the ABA-problem~\ref{ABA}. 
For example, a thread could determine that it should replace a reference to a \descr{Node} object with a new \descr{Node} object.
However, before calling the \op{cas} operation, the object was removed and reallocated to another thread.
That thread, then placed the object at the same location it was removed from.
The first thread would be unaware that the contents of the \descr{Node} has changed, would incorrectly replace it.

For brevity and clarity, the pseudocode omits code related to the unbitmarking of references.
If a reference has been determined to hold a bitmark (i.e. \op{isSkipped} returning true), the next step would be to remove the bitmark from the local copy before dereferencing the object.

The use of the sequence identifiers introduces the \textit{theoretical} danger where the value rolls over, leading to two threads being assigned the same \emph{seqid}.
In the following algorithm discussions, we assume the sequence identifier does not have a maximum value and thus can not roll over.
The tested implementation uses a 64 bit signed long, which allows the ring buffer to support a maximum of $2^{63}$ enqueue operations.
In the event a roll over occurs, indicated by a negative result when incrementing a sequence counter, our implementation will creates a new internal ring buffer object where all subsequent elements are enqueued.
This is safe for systems using less than $2^{63}$ threads.

To achieve FIFO behavior of our ring buffer, we make the restriction that an element can only be dequeued by a thread whose \emph{seqid} matches the \emph{seqid} of the \descr{Node} containing the element.
To prevent the case where other threads maybe blocked in the event a dequeuer never removes its assigned element, we developed a method by which a thread is able to safely skip a position that holds a value assigned to another thread.